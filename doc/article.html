<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>OpenTheory Article Format Version 2</title>
<meta name="keywords" content="proofs, higher order logic" />
</head>

<body>

<table cellpadding="2">
<tr>
<td><a href="index.html">home</a></td>
<td width="20"></td>
<td><a href="goal.html">project goals</a></td>
<td width="20"></td>
<td bgcolor="yellow">article format</td>
<td width="20"></td>
<td><a href="examples.html">article examples</a></td>
</tr>
</table>

<hr />

<h2>OpenTheory Article Format Version 2</h2>

<p>An <em>article</em> is a file containing the statements and proofs
of some number of theorems. Articles are not required to be
self-contained, and may refer to external types, constants and
theorems in the theorem proving system reading the article.</p>

<h3>Overview</h3>

<p>Articles take the form of a sequence of commands to be executed by
a stack-based virtual machine. The command language has much in common
with PostScript, including commands to store and retrieve objects from
a dictionary.</p>

<h3>Types</h3>

<p>The primitive types are:

<dl>
<dt><kbd>num</kbd></dt>

<dd>Non-negative integers, such as <em>0</em>, <em>13</em> and
<em>42</em>.</dd>

<dt><kbd>name</kbd></dt>

<dd>Strings, such as <em>"foo"</em> and <em>""</em>.</dd>

<dt><kbd>type</kbd></dt>

<dd>Higher order logic types, such as <em>num</em> and <em>bool
list</em>.</dd>

<dt><kbd>term</kbd></dt>

<dd>Higher order logic terms, such as <em>13</em> and <em>!x.
x</em>.</dd>

<dt><kbd>thm</kbd></dt>

<dd>Higher order logic theorems, such as <em>|- x = x</em> and
<em>[x = y, y = T] |- x</em>.</dd>

</dl></p>

<p>The article language constructs values of type <kbd>object</kbd>,
which has the following ML-like definition:</p>

<table cellpadding="0" cellspacing="0">

<tr>
<td colspan="4"><kbd>datatype object =</kbd></td>
</tr>

<tr>
<td></td>
<td><kbd>Oerror</kbd></td>
<td width="40"></td>
<td>(* An error value *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Onum of num</kbd></td>
<td></td>
<td>(* A number *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Oname of name</kbd></td>
<td></td>
<td>(* A name *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Olist of object list</kbd></td>
<td></td>
<td>(* A list (or tuple) of objects *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Otype of type</kbd></td>
<td></td>
<td>(* A higher order logic type *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Oterm of term</kbd></td>
<td></td>
<td>(* A higher order logic term *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Othm of thm</kbd></td>
<td></td>
<td>(* A higher order logic theorem *)</td>
</tr>

<tr>
<td>&nbsp;<kbd>|</kbd>&nbsp;</td>
<td><kbd>Ocall of name</kbd></td>
<td></td>
<td>(* A special object marking a function call *)</td>
</tr>

</table>

<h3>Virtual Machine</h3>

<p>The virtual machine that reads in an article file is equipped with:

<ul>

<li>A <em>stack</em> containing values of type <kbd>object</kbd>,
where (as is usual with stacks) the last object to be inserted is
the first object to be removed. Initially the stack is empty.</li>

<li>A <em>dictionary</em> mapping keys of type <kbd>num</kbd> to
values of type <kbd>object</kbd>. Initially the dictionary is
empty.</li>

<li>An <em>export list</em> of type <kbd>thm list</kbd>.
Initially the export list is empty.</li>

</ul></p>

<p>Every line in an article file is either a comment line or a command
line. A comment line has <kbd>#</kbd> as its first character. Comment
lines are immediately discarded by the virtual machine. A command line
encodes exactly one command of the form below, and is immediately
executed. As a result of executing the command, the stack, dictionary
or export list may be altered. After a command line has been processed
it is discarded.</p>

<h3>Commands</h3>

<dl>
<dt><kbd>error</kbd></dt>

<dd>Push the object <kbd>Oerror</kbd> on to the stack.
<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Oerror :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><em>i</em> (the non-negative integer <em>i</em> represented as
a sequence of decimal digits)</dt>

<dd>Push the object <kbd>Onum i</kbd> on to the stack.
<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Onum i :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><em>"n"</em> (a quoted string <em>n</em>)</dt>

<dd>Push the object <kbd>Oname n</kbd> on to the stack.
<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Oname n :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>nil</kbd></dt>

<dd>Push the empty list <em>[]</em> on to the stack.
<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Olist [] :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>cons</kbd></dt>

<dd>Pop a list <em>t</em>; pop an object <em>h</em>; push the
list <em>h :: t</em> on to the stack.

<br /><strong>Note:</strong> The object <em>h</em> must not be
an <kbd>Ocall</kbd> object.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Olist t :: h :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Olist (h :: t) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>type_var</kbd>

<dd>Pop a name <em>n</em>; push a type variable with name
<em>n</em>.

<br /><strong>Note:</strong> An initial apostrophe is
<strong>not</strong> added to the name.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Oname n :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Otype (mk_type_var n) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>type_op</kbd>

<dd>Pop a list of types <em>l</em>; pop a name <em>n</em>; push a type
operator with name <em>n</em> and arguments <em>l</em>.

<br /><strong>Note:</strong> See the section <em>Constructing Types,
Constants and Theorems</em> below for more information on this
command.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Olist [Otype t1, ..., Otype tn] :: Oname n :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Otype (mk_type_op (n, [t1, ..., tn])) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>var</kbd>

<dd>Pop a type <em>ty</em>; pop a name <em>n</em>; push a variable
with name <em>n</em> and type <em>ty</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Otype ty :: Oname n :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Oterm (mk_var (n,ty)) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>const</kbd>

<dd>Pop a type <em>ty</em>; pop a name <em>n</em>; push a constant
with name <em>n</em> and type <em>ty</em>.

<br /><strong>Note:</strong> See the section <em>Constructing Types,
Constants and Theorems</em> below for more information on this
command.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Otype ty :: Oname n :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Oterm (mk_const (n,ty)) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>comb</kbd>

<dd>Pop a term <em>b</em>; pop a term <em>a</em>; push the function
application <em>a b</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Oterm b :: Oterm a :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Oterm (mk_comb (a,b)) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>abs</kbd>

<dd>Pop a term <em>b</em>; pop a variable term <em>v</em>; push the
lambda abstraction <em>\v. b</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Oterm b :: Oterm v :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Oterm (mk_abs (v,b)) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>thm</kbd>

<dd>Pop a term <em>c</em>; pop a list of terms <em>h</em>; push the
theorem <em>h |- c</em> with hypothesis <em>h</em> and
conclusion <em>c</em>.

<br /><strong>Note:</strong> See the section <em>Constructing Types,
Constants and Theorems</em> below for more information on this
command.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Oterm c :: Olist [Oterm h1, ..., Oterm hn] :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>Othm ([h1, ..., hn] |- c) :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>call</kbd>

<dd>Pop a name <em>n</em>; pop an object <em>i</em>; push the
function call marker <kbd>Ocall n</kbd>; push the input value
<em>i</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Oname n :: i :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>i :: Ocall n :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="5"></td></tr>
</table>
</dd>

<dt><kbd>return</kbd>

<dd>Pop a name <em>n</em>; pop an object <em>r</em>; pop objects
from the stack up to and including the top function call marker
<kbd>Ocall _</kbd>; push the return value <em>r</em>.

<br /><strong>Note:</strong> The argument <em>n'</em> to the top
function call marker <kbd>Ocall n'</kbd> should satisfy <em>n =
n'</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Oname n :: r :: ... :: Ocall n' :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>r :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="5"></td></tr>
</table>
</dd>

<dt><kbd>def</kbd>

<dd>Pop a number <em>k</em>; pop an object <em>x</em>; update the
dictionary so that key <em>k</em> maps to object <em>x</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Onum k :: x :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>stack</kbd><td>
</tr>
<tr><td colspan="5" height="5"></td></tr>
</table>
<table cellspacing="0" cellpadding="0">
<tr>
<th>Dictionary:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>dict</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>dict[k |-> x]</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>ref</kbd>

<dd>Pop a number <em>k</em>; look up key <em>k</em> in the
dictionary to get an object <em>x</em>; push the object <em>x</em>.

<br /><strong>Note:</strong> This command does not change the dictionary.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Onum k :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>dict[k] :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="5"></td></tr>
</table>
</dd>

<dt><kbd>dup</kbd>

<dd>Pop a number <em>n</em>; read the <em>n</em>th object <em>xn</em>
from the top of the stack (counting from 0); push the
object <em>xn</em>.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Onum n :: x0 :: ... :: xn :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>xn :: x0 :: ... :: xn :: stack</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

<dt><kbd>save</kbd>

<dd>Pop a theorem <em>th</em>; add <em>th</em> to the list of theorems
that the article will export.

<table cellspacing="0" cellpadding="0">
<tr>
<th>Stack:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>Othm th :: stack</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>stack</kbd><td>
</tr>
<tr><td colspan="5" height="5"></td></tr>
</table>
<table cellspacing="0" cellpadding="0">
<tr>
<th>Export list:</th>
<td width="10"></td>
<th align="left">Before:</th>
<td width="10"></td>
<td align="left"><kbd>saved</kbd><td>
</tr>
<tr>
<td></td>
<td></td>
<th align="left">After:</th>
<td></td>
<td align="left"><kbd>saved @ [th]</kbd><td>
</tr>
<tr><td colspan="5" height="10"></td></tr>
</table>
</dd>

</dl>

<h3>Constructing Types, Constants and Theorems</h3>

<h4>Theorems</h4>

<p>Much of the time the target theorem of a <kbd>theorem</kbd> command
is already available on the stack. If it is not, then it needs to be
constructed in another way. Read on.</p>

<p>The virtual machine executing the commands in the article is
expected to simulate at least the primitive inference rules of higher
order logic. For example, suppose the stack is

<blockquote>
<kbd>Oterm </kbd><em>t = t</em><kbd> :: Olist [] ::
Oterm </kbd><em>t</em><kbd> :: Ocall "Refl" :: stack</kbd>
</blockquote>

and the current command is <kbd>thm</kbd>. The virtual machine is
expected to simulate this reflexivity inference to produce the stack

<blockquote>
<kbd>Othm </kbd><em>[] |- t = t</em><kbd> ::
Oterm </kbd><em>t</em><kbd> :: Ocall "Refl" :: stack</kbd>
</blockquote></p>

<p>If a theorem cannot be created by simulation then the behaviour is
implementation dependent. Possibilities include:

<ol>

<li>Proving the theorem using the tools available in the current
system.</li>

<li>Creating a new axiom matching the new theorem, and adding the
axiom as a dependency of the article.</li>

</ol></p>

<h4>Type Operators and Constants</h4>

<p>Much of the time type operators and constants will be mapped to
existing type operators and constants within the theorem proving
system reading the article. For other type operators and constants
read on.</p>

<p>The virtual machine is expected to simulate the primitive
principles of definition. Suppose the stack is

<blockquote>
<kbd>Otype _ :: Oname </kbd><em>v</em><kbd> ::
Oterm </kbd><em>c = t</em><kbd> :: Ocall "DefineConst" :: stack</kbd>
</blockquote>

where <em>c</em> is a variable and the current command
is <kbd>const</kbd>. The virtual machine is expected to simulate this
constant definition to produce the stack

<blockquote>
<kbd>Oterm </kbd><em>c</em><kbd> :: Ocall "DefineConst" :: stack</kbd>
</blockquote></p>

where <em>c</em> is the constant being defined by this primitive
inference rule.</p>

<p>If a constant or type operator cannot be constructed by simulation
then the behaviour is again implementation dependent. Possibilities
include:

<ol>

<li>Creating a fresh type operator with the required arity or a fresh
constant with polymorphic type. This is logically sound.</li>

</ol></p>

<hr />

<i><a href = "http://www.gilith.com/about">Joe Hurd</a>,
12 December 2007</i>

</body>
</html>
