--------------------------------------------------------------------------
Symbol tables

--------------------------------------------------------------------------
Terms

[\p. p, \q. p, \q. q]

[\p. p, \q. q, \q. p]

[(let p = F in p) <=> F, (let q = q in p) <=> p, (let q = T in q) <=> T]

[(let p = F in p) <=> F, (let q = T in q) <=> T, (let q = q in p) <=> p]

\(\y. g (x /\ y)). g x

!(\y. g (x /\ y)). g x

let a d = (\e. d e) = d in a = \b. (\c. c) = \c. c

let a d =
    let e g =
        (let h = d g in
         \i.
           (let j = h in
            \k. (\l. l j k) = \m. m ((\c. c) = \c. c) ((\c. c) = \c. c))
             i <=> h) (d ((select) d)) in
    e = (\f. (\c. c) = \c. c) in
a = \b. (\c. c) = \c. c

let a o =
    (let h =
         let p r =
             let p s =
                 (let f = o r = o s in
                  \g.
                    (let h = f in
                     \i.
                       (\j. j h i) =
                       \k. k ((\d. d) = \d. d) ((\d. d) = \d. d)) g <=> f)
                   (r = s) in
             p = (\q. (\d. d) = \d. d) in
         p = (\q. (\d. d) = \d. d) in
     \i. (\j. j h i) = \k. k ((\d. d) = \d. d) ((\d. d) = \d. d))
      (let t =
           let p u =
               let v y = u = o y in
               let b w =
                   (let f =
                        let p x =
                            (let f = v x in
                             \g.
                               (let h = f in
                                \i.
                                  (\j. j h i) =
                                  \k.
                                    k ((\d. d) = \d. d) ((\d. d) = \d. d))
                                 g <=> f) w in
                        p = (\q. (\d. d) = \d. d) in
                    \g.
                      (let h = f in
                       \i.
                         (\j. j h i) =
                         \k. k ((\d. d) = \d. d) ((\d. d) = \d. d)) g <=>
                      f) w in
               b = (\c. (\d. d) = \d. d) in
           p = (\q. (\d. d) = \d. d) in
       (let f = t in
        \g.
          (let h = f in
           \i. (\j. j h i) = \k. k ((\d. d) = \d. d) ((\d. d) = \d. d))
            g <=> f) (let b d = d in b = \c. (\d. d) = \d. d)) in
let b e =
    (let f =
         let l n =
             (let f = a n in
              \g.
                (let h = f in
                 \i.
                   (\j. j h i) = \k. k ((\d. d) = \d. d) ((\d. d) = \d. d))
                  g <=> f) e in
         l = (\m. (\d. d) = \d. d) in
     \g.
       (let h = f in
        \i. (\j. j h i) = \k. k ((\d. d) = \d. d) ((\d. d) = \d. d)) g <=>
       f) e in
b = \c. (\d. d) = \d. d

--------------------------------------------------------------------------
Substitution

\q. q ==> p

([], [(p, q)])

\q0. q0 ==> q

\x. (!y. y) /\ y

([], [(y, x)])

\x0. (!y. y) /\ x

\x'.
  ((!x. ~s x \/ t x) /\ (s x /\ ~t x \/ ~s x /\ t x)) /\
  (!x. ~t x \/ u x) /\ (t x' /\ ~u x' \/ ~t x' /\ u x')

([], [(x, x')])

\x0.
  ((!x. ~s x \/ t x) /\ (s x' /\ ~t x' \/ ~s x' /\ t x')) /\
  (!x. ~t x \/ u x) /\ (t x0 /\ ~u x0 \/ ~t x0 /\ u x0)

--------------------------------------------------------------------------
Reading interpretations

type "HOLLight.bool" as "bool"
type "HOLLight.fun" as "->"
const "HOLLight.=" as "="
const "HOLLight.T" as "Data.Bool.T"

--------------------------------------------------------------------------
Compressing articles

Compressing article "empty"

Compressing article "example1"

Compressing article "example2"

Compressing article "example3"

Compressing article "example4"

Compressing article "bool-true-def"
WARNING: 15 objects left in the dictionary by articles/hol-light/bool-true-def.art

Compressing article "bool-true-thm"
WARNING: 22 objects left in the dictionary by articles/hol-light/bool-true-thm.art

--------------------------------------------------------------------------
Summarizing articles

Summarizing compressed article "empty"


Summarizing compressed article "example1"
1 input type operator: bool
1 input constant: T
1 assumption:
  |- T
1 theorem:
  |- T

Summarizing compressed article "example2"
1 input type operator: bool
1 input constant: T
1 assumption:
  |- let x = T in x
1 theorem:
  |- let y = T in y

Summarizing compressed article "example3"
2 input type operators: -> bool
1 input constant: =
1 theorem:
  |- x = x

Summarizing compressed article "example4"
2 input type operators: -> bool
1 input constant: =
1 theorem:
  |- x = x

Summarizing compressed article "bool-true-def"
2 input type operators: -> bool
1 input constant: =
1 defined constant: T
1 theorem:
  |- T <=> (\p. p) = \p. p

Summarizing compressed article "bool-true-thm"
2 input type operators: -> bool
2 input constants: = T
1 assumption:
  |- T <=> (\p. p) = \p. p
1 theorem:
  |- T

--------------------------------------------------------------------------
Theory package directories

<directory>

--------------------------------------------------------------------------
Config files

[repo]
name = gilith
url = http://opentheory.gilith.com/
refresh = 604800

[license]
name = MIT
url = http://www.gilith.com/research/opentheory/licenses/MIT.txt

[license]
name = HOLLight
url = http://www.gilith.com/research/opentheory/licenses/HOLLight.txt

[cleanup]
auto = 3600

[install]
minimal = false

[system]
chmod = chmod
cp = cp
curl = curl --silent --show-error --user-agent opentheory
echo = echo
sha = sha1sum --binary
tar = tar

--------------------------------------------------------------------------
Importing theory packages

Importing theory package "empty-1.0"


Importing theory package "bool-true-def-1.0"
2 input type operators: -> bool
1 input constant: =
1 defined constant: T
1 theorem:
  |- T <=> (\p. p) = \p. p

Importing theory package "bool-true-thm-1.0"
2 input type operators: -> bool
2 input constants: = T
1 assumption:
  |- T <=> (\p. p) = \p. p
1 theorem:
  |- T

Importing theory package "bool-true-1.0"
2 input type operators: -> bool
1 input constant: =
1 defined constant: T
2 theorems:
  |- T
  |- T <=> (\p. p) = \p. p

Importing theory package "bool-true-assert-1.0"
2 input type operators: -> bool
2 input constants: = T
1 assumption:
  |- T <=> (\a. T) = \b. b
1 theorem:
  |- T <=> (\a. T) = \b. b

Importing theory package "bool-true-axiom-1.0"
2 input type operators: -> bool
1 input constant: =
1 defined constant: T
1 axiom:
  |- T <=> (\a. T) = \b. b
2 theorems:
  |- T <=> (\a. T) = \b. b
  |- T <=> (\p. p) = \p. p

