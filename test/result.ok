--------------------------------------------------------------------------
Symbol tables

--------------------------------------------------------------------------
Terms

[\p. p, \q. p, \q. q]

[\p. p, \q. q, \q. p]

[(\p. p) F <=> F, (\q. p) q <=> p, (\q. q) T <=> T]

[(\p. p) F <=> F, (\q. q) T <=> T, (\q. p) q <=> p]

\(\y. g (x /\ y)). g x

!(\y. g (x /\ y)). g x

--------------------------------------------------------------------------
Substitution

\q. q ==> p

([], [(p, q)])

\q0. q0 ==> q

\x. (!y. y) /\ y

([], [(y, x)])

\x0. (!y. y) /\ x

\x'.
  ((!x. ~s x \/ t x) /\ (s x /\ ~t x \/ ~s x /\ t x)) /\
  (!x. ~t x \/ u x) /\ (t x' /\ ~u x' \/ ~t x' /\ u x')

([], [(x, x')])

\x0.
  ((!x. ~s x \/ t x) /\ (s x' /\ ~t x' \/ ~s x' /\ t x')) /\
  (!x. ~t x \/ u x) /\ (t x0 /\ ~u x0 \/ ~t x0 /\ u x0)

--------------------------------------------------------------------------
Reading interpretations

type "1" as "Data.Unit.unit"
type "fun" as "->"
type "list" as "Data.List.list"
type "num" as "Number.Natural.nat"
type "option" as "Data.Option.option"
type "prod" as "Data.Pair.*"
type "sum" as "Data.Sum.+"
const "!" as "Data.Bool.!"
const "*" as "Number.Natural.*"
const "+" as "Number.Natural.+"
const "," as "Data.Pair.,"
const "-" as "Number.Natural.-"
const "/\\" as "Data.Bool./\\"
const "<" as "Number.Natural.<"
const "<=" as "Number.Natural.<="
const "==>" as "Data.Bool.==>"
const ">" as "Number.Natural.>"
const ">=" as "Number.Natural.>="
const "?" as "Data.Bool.?"
const "?!" as "Data.Bool.?!"
const "@" as "Data.Bool.select"
const "BIT0" as "Number.Numeral.bit0"
const "BIT1" as "Number.Numeral.bit1"
const "COND" as "Data.Bool.cond"
const "CONS" as "Data.List.::"
const "DIV" as "Number.Natural.div"
const "EVEN" as "Number.Natural.even"
const "EXP" as "Number.Natural.exp"
const "F" as "Data.Bool.F"
const "FACT" as "Number.Natural.factorial"
const "FST" as "Data.Pair.fst"
const "GABS" as "Data.Bool.select"
const "GEQ" as "="
const "I" as "Function.id"
const "INL" as "Data.Sum.left"
const "INR" as "Data.Sum.right"
const "LET" as "Data.Bool.let"
const "LET_END" as "Unwanted.id"
const "MAX" as "Number.Natural.max"
const "MEASURE" as "Relation.measure"
const "MIN" as "Number.Natural.min"
const "MOD" as "Number.Natural.mod"
const "NIL" as "Data.List.[]"
const "NONE" as "Data.Option.none"
const "NUMERAL" as "Unwanted.id"
const "ODD" as "Number.Natural.odd"
const "ONE_ONE" as "Function.injective"
const "ONTO" as "Function.surjective"
const "OUTL" as "Data.Sum.destLeft"
const "OUTR" as "Data.Sum.destRight"
const "PRE" as "Number.Natural.pre"
const "SND" as "Data.Pair.snd"
const "SOME" as "Data.Option.some"
const "SUC" as "Number.Natural.suc"
const "T" as "Data.Bool.T"
const "WF" as "Relation.wellFounded"
const "\\/" as "Data.Bool.\\/"
const "_0" as "Number.Numeral.zero"
const "minimal" as "Number.Natural.minimal"
const "o" as "Function.o"
const "one" as "Data.Unit.()"
const "~" as "Data.Bool.~"

--------------------------------------------------------------------------
Compressing articles

Compressing article "empty"
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000

Compressing article "example1"
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000

Compressing article "example2"
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001

Compressing article "example3"
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001

Compressing article "example4"
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001

Compressing article "bool-def-true"
WARNING: 19 objects left in the dictionary by articles/hol-light/bool-def-true.art
User: 0.002  System: 0.000  GC: 0.000  Real: 0.002
User: 0.002  System: 0.000  GC: 0.000  Real: 0.002

Compressing article "bool-int-true"
WARNING: 26 objects left in the dictionary by articles/hol-light/bool-int-true.art
User: 0.003  System: 0.000  GC: 0.000  Real: 0.003
User: 0.002  System: 0.000  GC: 0.000  Real: 0.002

Compressing article "bool-true-aux"
WARNING: 24 objects left in the dictionary by articles/hol-light/bool-true-aux.art
User: 0.003  System: 0.000  GC: 0.000  Real: 0.003
User: 0.002  System: 0.000  GC: 0.000  Real: 0.002

--------------------------------------------------------------------------
Summarizing articles

Summarizing compressed article "empty"
assumptions:
axioms:
theorems:

Summarizing compressed article "example1"
input-types: bool
input-consts: T
assumptions:
  |- T
axioms:
theorems:
  |- T

Summarizing compressed article "example2"
input-types: bool
input-consts: T
assumptions:
  |- (\x. x) T
axioms:
theorems:
  |- (\y. y) T

Summarizing compressed article "example3"
input-types: -> bool
input-consts: =
assumptions:
axioms:
theorems:
  |- x = x

Summarizing compressed article "example4"
input-types: -> bool
input-consts: =
assumptions:
axioms:
theorems:
  |- x = x

Summarizing compressed article "bool-def-true"
input-types: -> bool
input-consts: =
assumptions:
defined-consts: T
axioms:
theorems:
  |- T <=> (\p. p) = \p. p

Summarizing compressed article "bool-int-true"
input-types: -> bool
input-consts: = T
assumptions:
  |- T <=> (\p. p) = \p. p
axioms:
theorems:
  |- T

Summarizing compressed article "bool-true-aux"
input-types: -> bool
input-consts: = T
assumptions:
  |- T
axioms:
theorems:
  |- t <=> t <=> T

--------------------------------------------------------------------------
Theory package directories

<directory>

--------------------------------------------------------------------------
Config files

[repo]
name = gilith
url = http://opentheory.gilith.com/
refresh = 604800

[install]
cleanup = 3600

[system]
chmod = chmod
cp = cp
curl = curl --silent --show-error --user-agent opentheory
echo = echo
sha = sha1sum --binary
tar = tar

--------------------------------------------------------------------------
Importing theory packages

Importing theory package "empty-1.0"
assumptions:
axioms:
theorems:

Importing theory package "bool-def-true-1.0"
input-types: -> bool
input-consts: =
assumptions:
defined-consts: T
axioms:
theorems:
  |- T <=> (\p. p) = \p. p

Importing theory package "bool-int-true-1.0"
input-types: -> bool
input-consts: = T
assumptions:
  |- T <=> (\p. p) = \p. p
axioms:
theorems:
  |- T

Importing theory package "bool-true-1.0"
input-types: -> bool
input-consts: =
assumptions:
defined-consts: T
axioms:
theorems:
  |- T
  |- T <=> (\p. p) = \p. p

