--------------------------------------------------------------------------
Symbol tables

--------------------------------------------------------------------------
Terms

[\p. p, \q. p, \q. q]

[\p. p, \q. q, \q. p]

[(\p. p) F <=> F, (\q. p) q <=> p, (\q. q) T <=> T]

[(\p. p) F <=> F, (\q. q) T <=> T, (\q. p) q <=> p]

\(\y. g (x /\ y)). g x

!(\y. g (x /\ y)). g x

--------------------------------------------------------------------------
Substitution

\q. q ==> p

([], [(p, q)])

\q0. q0 ==> q

\x. (!y. y) /\ y

([], [(y, x)])

\x0. (!y. y) /\ x

\x'.
  ((!x. ~s x \/ t x) /\ (s x /\ ~t x \/ ~s x /\ t x)) /\
  (!x. ~t x \/ u x) /\ (t x' /\ ~u x' \/ ~t x' /\ u x')

([], [(x, x')])

\x0.
  ((!x. ~s x \/ t x) /\ (s x' /\ ~t x' \/ ~s x' /\ t x')) /\
  (!x. ~t x \/ u x) /\ (t x0 /\ ~u x0 \/ ~t x0 /\ u x0)

--------------------------------------------------------------------------
Reading interpretations

type "HOLLight.1" as "Data.Unit.unit"
type "HOLLight.bool" as "bool"
type "HOLLight.fun" as "->"
type "HOLLight.ind" as "ind"
type "HOLLight.list" as "Data.List.list"
type "HOLLight.num" as "Number.Natural.natural"
type "HOLLight.option" as "Data.Option.option"
type "HOLLight.prod" as "Data.Pair.*"
type "HOLLight.sum" as "Data.Sum.+"
const "HOLLight.!" as "Data.Bool.!"
const "HOLLight.*" as "Number.Natural.*"
const "HOLLight.+" as "Number.Natural.+"
const "HOLLight.," as "Data.Pair.,"
const "HOLLight.-" as "Number.Natural.-"
const "HOLLight./\\" as "Data.Bool./\\"
const "HOLLight.<" as "Number.Natural.<"
const "HOLLight.<=" as "Number.Natural.<="
const "HOLLight.=" as "="
const "HOLLight.==>" as "Data.Bool.==>"
const "HOLLight.>" as "Number.Natural.>"
const "HOLLight.>=" as "Number.Natural.>="
const "HOLLight.?" as "Data.Bool.?"
const "HOLLight.?!" as "Data.Bool.?!"
const "HOLLight.@" as "Data.Bool.select"
const "HOLLight.\\/" as "Data.Bool.\\/"
const "HOLLight._0" as "Number.Numeral.zero"
const "HOLLight.~" as "Data.Bool.~"
const "HOLLight.minimal" as "Number.Natural.minimal"
const "HOLLight.o" as "Function.o"
const "HOLLight.one" as "Data.Unit.()"
const "HOLLight.ALL" as "Data.List.all"
const "HOLLight.APPEND" as "Data.List.@"
const "HOLLight.BIT0" as "Number.Numeral.bit0"
const "HOLLight.BIT1" as "Number.Numeral.bit1"
const "HOLLight.COND" as "Data.Bool.cond"
const "HOLLight.CONS" as "Data.List.::"
const "HOLLight.DIV" as "Number.Natural.div"
const "HOLLight.EL" as "Data.List.nth"
const "HOLLight.EVEN" as "Number.Natural.even"
const "HOLLight.EX" as "Data.List.exists"
const "HOLLight.EXP" as "Number.Natural.exp"
const "HOLLight.F" as "Data.Bool.F"
const "HOLLight.FACT" as "Number.Natural.factorial"
const "HOLLight.FILTER" as "Data.List.filter"
const "HOLLight.FST" as "Data.Pair.fst"
const "HOLLight.GABS" as "Data.Bool.select"
const "HOLLight.GEQ" as "="
const "HOLLight.HD" as "Data.List.head"
const "HOLLight.I" as "Function.id"
const "HOLLight.INL" as "Data.Sum.left"
const "HOLLight.INR" as "Data.Sum.right"
const "HOLLight.LAST" as "Data.List.last"
const "HOLLight.LENGTH" as "Data.List.length"
const "HOLLight.LET" as "Data.Bool.let"
const "HOLLight.LET_END" as "Unwanted.id"
const "HOLLight.MAP" as "Data.List.map"
const "HOLLight.MAX" as "Number.Natural.max"
const "HOLLight.MEASURE" as "Relation.measure"
const "HOLLight.MEM" as "Data.List.member"
const "HOLLight.MIN" as "Number.Natural.min"
const "HOLLight.MOD" as "Number.Natural.mod"
const "HOLLight.NIL" as "Data.List.[]"
const "HOLLight.NONE" as "Data.Option.none"
const "HOLLight.NULL" as "Data.List.null"
const "HOLLight.NUMERAL" as "Unwanted.id"
const "HOLLight.ODD" as "Number.Natural.odd"
const "HOLLight.ONE_ONE" as "Function.injective"
const "HOLLight.ONTO" as "Function.surjective"
const "HOLLight.OUTL" as "Data.Sum.destLeft"
const "HOLLight.OUTR" as "Data.Sum.destRight"
const "HOLLight.PRE" as "Number.Natural.pre"
const "HOLLight.REPLICATE" as "Data.List.replicate"
const "HOLLight.REVERSE" as "Data.List.reverse"
const "HOLLight.SND" as "Data.Pair.snd"
const "HOLLight.SOME" as "Data.Option.some"
const "HOLLight.SUC" as "Number.Natural.suc"
const "HOLLight.T" as "Data.Bool.T"
const "HOLLight.TL" as "Data.List.tail"
const "HOLLight.WF" as "Relation.wellFounded"

--------------------------------------------------------------------------
Compressing articles

Compressing article "empty"
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000

Compressing article "example1"
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000
User: 0.000  System: 0.000  GC: 0.000  Real: 0.000

Compressing article "example2"
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001

Compressing article "example3"
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001

Compressing article "example4"
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001
User: 0.001  System: 0.000  GC: 0.000  Real: 0.001

Compressing article "bool-true-def"
WARNING: 15 objects left in the dictionary by articles/hol-light/bool-true-def.art
User: 0.003  System: 0.000  GC: 0.000  Real: 0.003
User: 0.002  System: 0.000  GC: 0.000  Real: 0.002

Compressing article "bool-true-thm"
WARNING: 22 objects left in the dictionary by articles/hol-light/bool-true-thm.art
User: 0.003  System: 0.000  GC: 0.000  Real: 0.003
User: 0.002  System: 0.000  GC: 0.000  Real: 0.002

--------------------------------------------------------------------------
Summarizing articles

Summarizing compressed article "empty"
assumptions:
axioms:
theorems:

Summarizing compressed article "example1"
input type operators: bool
input constants: T
assumptions:
  |- T
axioms:
theorems:
  |- T

Summarizing compressed article "example2"
input type operators: bool
input constants: T
assumptions:
  |- (\x. x) T
axioms:
theorems:
  |- (\y. y) T

Summarizing compressed article "example3"
input type operators: -> bool
input constants: =
assumptions:
axioms:
theorems:
  |- x = x

Summarizing compressed article "example4"
input type operators: -> bool
input constants: =
assumptions:
axioms:
theorems:
  |- x = x

Summarizing compressed article "bool-true-def"
input type operators: -> bool
input constants: =
assumptions:
defined constants: T
axioms:
theorems:
  |- T <=> (\p. p) = \p. p

Summarizing compressed article "bool-true-thm"
input type operators: -> bool
input constants: = T
assumptions:
  |- T <=> (\p. p) = \p. p
axioms:
theorems:
  |- T

--------------------------------------------------------------------------
Theory package directories

<directory>

--------------------------------------------------------------------------
Config files

[repo]
name = gilith
url = http://opentheory.gilith.com/
refresh = 604800

[license]
name = MIT
url = http://www.gilith.com/research/opentheory/licenses/MIT.txt

[license]
name = HOLLight
url = http://www.gilith.com/research/opentheory/licenses/HOLLight.txt

[install]
cleanup = 3600

[system]
chmod = chmod
cp = cp
curl = curl --silent --show-error --user-agent opentheory
echo = echo
sha = sha1sum --binary
tar = tar

--------------------------------------------------------------------------
Importing theory packages

Importing theory package "empty-1.0"
assumptions:
axioms:
theorems:

Importing theory package "bool-true-def-1.0"
input type operators: -> bool
input constants: =
assumptions:
defined constants: T
axioms:
theorems:
  |- T <=> (\p. p) = \p. p

Importing theory package "bool-true-thm-1.0"
input type operators: -> bool
input constants: = T
assumptions:
  |- T <=> (\p. p) = \p. p
axioms:
theorems:
  |- T

Importing theory package "bool-true-1.0"
input type operators: -> bool
input constants: =
assumptions:
defined constants: T
axioms:
theorems:
  |- T
  |- T <=> (\p. p) = \p. p

